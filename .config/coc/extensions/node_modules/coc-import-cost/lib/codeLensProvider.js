"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const import_cost_1 = require("import-cost");
const coc_nvim_1 = require("coc.nvim");
const filesize_1 = tslib_1.__importDefault(require("filesize"));
const logger_1 = tslib_1.__importDefault(require("./logger"));
function language(doc) {
    const fileName = doc.uri;
    const languageId = doc.fileType;
    const configuration = coc_nvim_1.workspace.getConfiguration('importCost');
    const typescriptRegex = new RegExp(configuration.typescriptExtensions.join('|'));
    const javascriptRegex = new RegExp(configuration.javascriptExtensions.join('|'));
    if (languageId === 'typescript' ||
        languageId === 'typescriptreact' ||
        typescriptRegex.test(fileName)) {
        return import_cost_1.TYPESCRIPT;
    }
    else if (languageId === 'javascript' ||
        languageId === 'javascriptreact' ||
        javascriptRegex.test(fileName)) {
        return import_cost_1.JAVASCRIPT;
    }
    else {
        return undefined;
    }
}
function getDecorationMessage(packageInfo) {
    if (packageInfo.size <= 0) {
        return '';
    }
    let decorationMessage;
    const configuration = coc_nvim_1.workspace.getConfiguration('importCost');
    const size = filesize_1.default(packageInfo.size, { unix: true });
    const gzip = filesize_1.default(packageInfo.gzip, { unix: true });
    if (configuration.bundleSizeDecoration === 'both') {
        decorationMessage = `${size} (gzipped: ${gzip})`;
    }
    else if (configuration.bundleSizeDecoration === 'minified') {
        decorationMessage = size;
    }
    else if (configuration.bundleSizeDecoration === 'gzipped') {
        decorationMessage = gzip;
    }
    return decorationMessage;
}
const uriFileProtocol = 'file://';
function getFileName(uri) {
    if (uri.startsWith(uriFileProtocol)) {
        return uri.slice(uriFileProtocol.length);
    }
    else {
        return uri;
    }
}
class ImportCostCodeLensProvider {
    constructor(isActive) {
        this.isActive = () => true;
        this.isActive = isActive;
    }
    provideCodeLenses(document, token) {
        return new Promise((resolve, reject) => {
            if (!this.isActive()) {
                resolve([]);
            }
            const fileName = getFileName(document.uri);
            const { timeout } = coc_nvim_1.workspace.getConfiguration('importCost');
            try {
                const emitter = import_cost_1.importCost(fileName, document.getText(), language(document), { concurrent: true, maxCallTime: timeout });
                emitter.on('done', packages => {
                    try {
                        const imports = packages.filter(pkg => pkg.size > 0).map(pkg => {
                            logger_1.default.log(`done with ${pkg.name}: ${JSON.stringify(pkg, null, 2)}`);
                            return calculated(pkg);
                        });
                        logger_1.default.log(`resolving promise with: ${JSON.stringify({ imports }, null, 2)}`);
                        resolve(imports);
                    }
                    catch (e) {
                        logger_1.default.log(`Exception in done emitter: ${e}`);
                        resolve();
                    }
                });
                emitter.on('error', e => {
                    logger_1.default.log(`error while calculating import costs for ${fileName}: ${e}`);
                });
            }
            catch (e) {
                resolve();
            }
        });
    }
    resolveCodeLens(codeLens, token) {
        return Promise.resolve(codeLens);
    }
}
exports.default = ImportCostCodeLensProvider;
function calculated(packageInfo) {
    const decorationMessage = getDecorationMessage(packageInfo);
    return makeCodeLens(decorationMessage, packageInfo);
}
function makeCodeLens(text, packageInfo) {
    const { fileName, line } = packageInfo;
    const position = { line: packageInfo.line - 1, character: 1024 };
    logger_1.default.log(`Setting Decoration: ${text}, ${JSON.stringify(packageInfo, null, 2)}`);
    const codeLens = {
        command: { title: text },
        range: { start: position, end: position },
        data: { fileName }
    };
    return codeLens;
}
//# sourceMappingURL=codeLensProvider.js.map